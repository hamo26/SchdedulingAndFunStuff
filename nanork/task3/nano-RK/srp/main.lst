   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 137               		.data
 138               	.LC0:
 139 0000 5461 736B 		.string	"Task3 PID=%d\r\n"
 139      3320 5049 
 139      443D 2564 
 139      0D0A 00
 140               	.LC1:
 141 000f 5461 736B 		.string	"Task1 cnt=%d\r\n"
 141      3120 636E 
 141      743D 2564 
 141      0D0A 00
 142               		.text
 144               	.global	Task3
 146               	Task3:
 147               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        ****  *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        ****  *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        ****  *  All rights reserved.
   5:main.c        ****  *
   6:main.c        ****  *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        ****  *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        ****  *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        ****  *
  10:main.c        ****  *  This program is free software: you can redistribute it and/or modify
  11:main.c        ****  *  it under the terms of the GNU General Public License as published by
  12:main.c        ****  *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        ****  *
  14:main.c        ****  *  This program is distributed in the hope that it will be useful,
  15:main.c        ****  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        ****  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        ****  *  GNU General Public License for more details.
  18:main.c        ****  *
  19:main.c        ****  *  You should have received a copy of the GNU General Public License
  20:main.c        ****  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        ****  *
  22:main.c        ****  *  Contributing Authors (specific to this file):
  23:main.c        ****  *  Zane Starr
  24:main.c        ****  *******************************************************************************/
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** #include <nrk.h>
  28:main.c        **** #include <include.h>
  29:main.c        **** #include <ulib.h>
  30:main.c        **** #include <stdio.h>
  31:main.c        **** #include <avr/sleep.h>
  32:main.c        **** #include <hal.h>
  33:main.c        **** #include <nrk_error.h>
  34:main.c        **** #include <nrk_events.h>
  35:main.c        **** #include <nrk_timer.h>
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  39:main.c        **** nrk_task_type TaskOne;
  40:main.c        **** void Task1(void);
  41:main.c        **** 
  42:main.c        **** NRK_STK Stack2[NRK_APP_STACKSIZE];
  43:main.c        **** nrk_task_type TaskTwo;
  44:main.c        **** void Task2 (void);
  45:main.c        **** 
  46:main.c        **** NRK_STK Stack3[NRK_APP_STACKSIZE];
  47:main.c        **** nrk_task_type TaskThree;
  48:main.c        **** void Task3 (void);
  49:main.c        **** 
  50:main.c        **** void nrk_create_taskset();
  51:main.c        **** 
  52:main.c        **** nrk_sem_t *my_semaphore;
  53:main.c        **** 
  54:main.c        ****     int
  55:main.c        **** main ()
  56:main.c        **** {
  57:main.c        ****     uint8_t t;
  58:main.c        ****     nrk_setup_ports();
  59:main.c        ****     nrk_setup_uart(UART_BAUDRATE_115K2);
  60:main.c        **** 
  61:main.c        ****     printf( "Starting up...\r\n" );
  62:main.c        **** 
  63:main.c        ****     nrk_init();
  64:main.c        **** 
  65:main.c        ****     nrk_led_clr(ORANGE_LED);
  66:main.c        ****     nrk_led_clr(BLUE_LED);
  67:main.c        ****     nrk_led_set(GREEN_LED);
  68:main.c        ****     nrk_led_clr(RED_LED);
  69:main.c        **** 
  70:main.c        ****     nrk_time_set(0,0);
  71:main.c        ****     nrk_create_taskset ();
  72:main.c        **** 
  73:main.c        ****     //instead of passing the ceiling priority, the task with the shortest period that accesses the 
  74:main.c        ****     //in this case, task1 which has a period 350*NANOS_PER_MS
  75:main.c        ****     my_semaphore = nrk_sem_create(1,350*NANOS_PER_MS);
  76:main.c        ****     if(my_semaphore==NULL) nrk_kprintf( PSTR("Error creating sem\r\n" ));
  77:main.c        ****     nrk_start();
  78:main.c        **** 
  79:main.c        ****     return 0;
  80:main.c        **** }
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** void Task1()
  84:main.c        **** {
  85:main.c        ****     uint16_t cnt;
  86:main.c        ****     int8_t v;
  87:main.c        **** 
  88:main.c        ****     printf( "My node's address is %d\r\n",NODE_ADDR );
  89:main.c        **** 
  90:main.c        ****     printf( "Task1 PID=%d\r\n",nrk_get_pid());
  91:main.c        ****     cnt=0;
  92:main.c        ****     while(1) {
  93:main.c        **** 	nrk_led_toggle(ORANGE_LED);
  94:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
  95:main.c        **** 	nrk_kprintf( PSTR("Task1 accessing semaphore\r\n"));
  96:main.c        **** 	v = nrk_sem_pend(my_semaphore);
  97:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error pend\r\n"));
  98:main.c        **** 	nrk_kprintf( PSTR("Task1 holding semaphore\r\n"));
  99:main.c        **** 	// wait some time inside semaphore to show the effect
 100:main.c        **** 	nrk_wait_until_next_period();
 101:main.c        **** 	v = nrk_sem_post(my_semaphore);
 102:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error post\r\n"));
 103:main.c        **** 	nrk_kprintf( PSTR("Task1 released semaphore\r\n"));
 104:main.c        **** 	nrk_wait_until_next_period();
 105:main.c        **** 	cnt++;
 106:main.c        ****     }
 107:main.c        **** }
 108:main.c        **** 
 109:main.c        **** void Task2()
 110:main.c        **** {
 111:main.c        ****     uint8_t cnt;
 112:main.c        ****     int8_t v;
 113:main.c        **** 
 114:main.c        ****     printf( "Task2 PID=%d\r\n",nrk_get_pid());
 115:main.c        ****     cnt=0;
 116:main.c        ****     while(1) {
 117:main.c        **** 	nrk_led_toggle(ORANGE_LED);
 118:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 119:main.c        **** 	nrk_kprintf( PSTR("Task2 accessing semaphore\r\n"));
 120:main.c        **** 	v = nrk_sem_pend(my_semaphore);
 121:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error pend\r\n"));
 122:main.c        **** 	nrk_kprintf( PSTR("Task2 holding semaphore\r\n"));
 123:main.c        **** 	// wait some time inside semaphore to show the effect
 124:main.c        **** 	nrk_wait_until_next_period();
 125:main.c        **** 	v = nrk_sem_post(my_semaphore);
 126:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error post\r\n"));
 127:main.c        **** 	nrk_kprintf( PSTR("Task2 released semaphore\r\n"));
 128:main.c        **** 	nrk_wait_until_next_period();
 129:main.c        **** 	cnt++;
 130:main.c        ****     }
 131:main.c        **** 
 132:main.c        **** 
 133:main.c        **** 
 134:main.c        **** }
 135:main.c        **** 
 136:main.c        **** void Task3()
 137:main.c        **** {
 149               	.LM0:
 150               	.LFBB1:
 151 0000 1F93      		push r17
 152 0002 CF93      		push r28
 153 0004 DF93      		push r29
 154               	/* prologue: function */
 155               	/* frame size = 0 */
 156               	/* stack size = 3 */
 157               	.L__stack_usage = 3
 138:main.c        ****     //a task that is used to check if our implementation is correct. this task should norally be ab
 139:main.c        ****     //any other task if it has the earliest absolute deadline
 140:main.c        ****     uint8_t cnt;
 141:main.c        ****     int8_t v;
 142:main.c        **** 
 143:main.c        ****     printf( "Task3 PID=%d\r\n",nrk_get_pid());
 159               	.LM1:
 160 0006 0E94 0000 		call nrk_get_pid
 161 000a 00D0      		rcall .
 162 000c 00D0      		rcall .
 163 000e EDB7      		in r30,__SP_L__
 164 0010 FEB7      		in r31,__SP_H__
 165 0012 3196      		adiw r30,1
 166 0014 20E0      		ldi r18,lo8(.LC0)
 167 0016 30E0      		ldi r19,hi8(.LC0)
 168 0018 ADB7      		in r26,__SP_L__
 169 001a BEB7      		in r27,__SP_H__
 170 001c 1296      		adiw r26,1+1
 171 001e 3C93      		st X,r19
 172 0020 2E93      		st -X,r18
 173 0022 1197      		sbiw r26,1
 174 0024 8283      		std Z+2,r24
 175 0026 1382      		std Z+3,__zero_reg__
 176 0028 0E94 0000 		call printf
 177 002c 0F90      		pop __tmp_reg__
 178 002e 0F90      		pop __tmp_reg__
 179 0030 0F90      		pop __tmp_reg__
 180 0032 0F90      		pop __tmp_reg__
 144:main.c        ****     cnt=0;
 182               	.LM2:
 183 0034 10E0      		ldi r17,lo8(0)
 145:main.c        ****     while(1) {
 146:main.c        **** 	nrk_led_toggle(ORANGE_LED);
 147:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 185               	.LM3:
 186 0036 C0E0      		ldi r28,lo8(.LC1)
 187 0038 D0E0      		ldi r29,hi8(.LC1)
 188               	.L4:
 146:main.c        **** 	nrk_led_toggle(ORANGE_LED);
 190               	.LM4:
 191 003a 80E0      		ldi r24,lo8(0)
 192 003c 90E0      		ldi r25,hi8(0)
 193 003e 0E94 0000 		call nrk_led_toggle
 195               	.LM5:
 196 0042 00D0      		rcall .
 197 0044 00D0      		rcall .
 198 0046 EDB7      		in r30,__SP_L__
 199 0048 FEB7      		in r31,__SP_H__
 200 004a 3196      		adiw r30,1
 201 004c ADB7      		in r26,__SP_L__
 202 004e BEB7      		in r27,__SP_H__
 203 0050 1296      		adiw r26,1+1
 204 0052 DC93      		st X,r29
 205 0054 CE93      		st -X,r28
 206 0056 1197      		sbiw r26,1
 207 0058 1283      		std Z+2,r17
 208 005a 1382      		std Z+3,__zero_reg__
 209 005c 0E94 0000 		call printf
 148:main.c        **** 	nrk_kprintf( PSTR("Task3 STARTED\r\n"));
 211               	.LM6:
 212 0060 0F90      		pop __tmp_reg__
 213 0062 0F90      		pop __tmp_reg__
 214 0064 0F90      		pop __tmp_reg__
 215 0066 0F90      		pop __tmp_reg__
 216 0068 80E0      		ldi r24,lo8(__c.2150)
 217 006a 90E0      		ldi r25,hi8(__c.2150)
 218 006c 0E94 0000 		call nrk_kprintf
 149:main.c        **** 	//v = nrk_sem_pend(my_semaphore);
 150:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error pend\r\n"));
 151:main.c        **** 	nrk_kprintf( PSTR("Task3 is running...\r\n"));
 220               	.LM7:
 221 0070 80E0      		ldi r24,lo8(__c.2154)
 222 0072 90E0      		ldi r25,hi8(__c.2154)
 223 0074 0E94 0000 		call nrk_kprintf
 152:main.c        **** 	// wait some time inside semaphore to show the effect
 153:main.c        **** 	nrk_wait_until_next_period();
 225               	.LM8:
 226 0078 0E94 0000 		call nrk_wait_until_next_period
 154:main.c        **** 	//v = nrk_sem_post(my_semaphore);
 155:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error post\r\n"));
 156:main.c        **** 	nrk_kprintf( PSTR("Task3 FINISHED\r\n"));
 228               	.LM9:
 229 007c 80E0      		ldi r24,lo8(__c.2158)
 230 007e 90E0      		ldi r25,hi8(__c.2158)
 231 0080 0E94 0000 		call nrk_kprintf
 157:main.c        **** 	nrk_wait_until_next_period();
 233               	.LM10:
 234 0084 0E94 0000 		call nrk_wait_until_next_period
 158:main.c        **** 	cnt++;
 236               	.LM11:
 237 0088 1F5F      		subi r17,lo8(-(1))
 159:main.c        ****     }
 239               	.LM12:
 240 008a 00C0      		rjmp .L4
 245               	.Lscope1:
 247               		.stabd	78,0,0
 248               		.data
 249               	.LC2:
 250 001e 5461 736B 		.string	"Task2 PID=%d\r\n"
 250      3220 5049 
 250      443D 2564 
 250      0D0A 00
 251               		.text
 253               	.global	Task2
 255               	Task2:
 256               		.stabd	46,0,0
 110:main.c        **** {
 258               	.LM13:
 259               	.LFBB2:
 260 008c 1F93      		push r17
 261 008e CF93      		push r28
 262 0090 DF93      		push r29
 263               	/* prologue: function */
 264               	/* frame size = 0 */
 265               	/* stack size = 3 */
 266               	.L__stack_usage = 3
 114:main.c        ****     printf( "Task2 PID=%d\r\n",nrk_get_pid());
 268               	.LM14:
 269 0092 0E94 0000 		call nrk_get_pid
 270 0096 00D0      		rcall .
 271 0098 00D0      		rcall .
 272 009a EDB7      		in r30,__SP_L__
 273 009c FEB7      		in r31,__SP_H__
 274 009e 3196      		adiw r30,1
 275 00a0 20E0      		ldi r18,lo8(.LC2)
 276 00a2 30E0      		ldi r19,hi8(.LC2)
 277 00a4 ADB7      		in r26,__SP_L__
 278 00a6 BEB7      		in r27,__SP_H__
 279 00a8 1296      		adiw r26,1+1
 280 00aa 3C93      		st X,r19
 281 00ac 2E93      		st -X,r18
 282 00ae 1197      		sbiw r26,1
 283 00b0 8283      		std Z+2,r24
 284 00b2 1382      		std Z+3,__zero_reg__
 285 00b4 0E94 0000 		call printf
 286 00b8 0F90      		pop __tmp_reg__
 287 00ba 0F90      		pop __tmp_reg__
 288 00bc 0F90      		pop __tmp_reg__
 289 00be 0F90      		pop __tmp_reg__
 115:main.c        ****     cnt=0;
 291               	.LM15:
 292 00c0 10E0      		ldi r17,lo8(0)
 118:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 294               	.LM16:
 295 00c2 C0E0      		ldi r28,lo8(.LC1)
 296 00c4 D0E0      		ldi r29,hi8(.LC1)
 297               	.L8:
 117:main.c        **** 	nrk_led_toggle(ORANGE_LED);
 299               	.LM17:
 300 00c6 80E0      		ldi r24,lo8(0)
 301 00c8 90E0      		ldi r25,hi8(0)
 302 00ca 0E94 0000 		call nrk_led_toggle
 118:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 304               	.LM18:
 305 00ce 00D0      		rcall .
 306 00d0 00D0      		rcall .
 307 00d2 EDB7      		in r30,__SP_L__
 308 00d4 FEB7      		in r31,__SP_H__
 309 00d6 3196      		adiw r30,1
 310 00d8 ADB7      		in r26,__SP_L__
 311 00da BEB7      		in r27,__SP_H__
 312 00dc 1296      		adiw r26,1+1
 313 00de DC93      		st X,r29
 314 00e0 CE93      		st -X,r28
 315 00e2 1197      		sbiw r26,1
 316 00e4 1283      		std Z+2,r17
 317 00e6 1382      		std Z+3,__zero_reg__
 318 00e8 0E94 0000 		call printf
 119:main.c        **** 	nrk_kprintf( PSTR("Task2 accessing semaphore\r\n"));
 320               	.LM19:
 321 00ec 0F90      		pop __tmp_reg__
 322 00ee 0F90      		pop __tmp_reg__
 323 00f0 0F90      		pop __tmp_reg__
 324 00f2 0F90      		pop __tmp_reg__
 325 00f4 80E0      		ldi r24,lo8(__c.2135)
 326 00f6 90E0      		ldi r25,hi8(__c.2135)
 327 00f8 0E94 0000 		call nrk_kprintf
 120:main.c        **** 	v = nrk_sem_pend(my_semaphore);
 329               	.LM20:
 330 00fc 8091 0000 		lds r24,my_semaphore
 331 0100 9091 0000 		lds r25,my_semaphore+1
 332 0104 0E94 0000 		call nrk_sem_pend
 121:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error pend\r\n"));
 334               	.LM21:
 335 0108 8F3F      		cpi r24,lo8(-1)
 336 010a 01F4      		brne .L6
 121:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error pend\r\n"));
 338               	.LM22:
 339 010c 80E0      		ldi r24,lo8(__c.2137)
 340 010e 90E0      		ldi r25,hi8(__c.2137)
 341 0110 0E94 0000 		call nrk_kprintf
 342               	.L6:
 122:main.c        **** 	nrk_kprintf( PSTR("Task2 holding semaphore\r\n"));
 344               	.LM23:
 345 0114 80E0      		ldi r24,lo8(__c.2139)
 346 0116 90E0      		ldi r25,hi8(__c.2139)
 347 0118 0E94 0000 		call nrk_kprintf
 124:main.c        **** 	nrk_wait_until_next_period();
 349               	.LM24:
 350 011c 0E94 0000 		call nrk_wait_until_next_period
 125:main.c        **** 	v = nrk_sem_post(my_semaphore);
 352               	.LM25:
 353 0120 8091 0000 		lds r24,my_semaphore
 354 0124 9091 0000 		lds r25,my_semaphore+1
 355 0128 0E94 0000 		call nrk_sem_post
 126:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error post\r\n"));
 357               	.LM26:
 358 012c 8F3F      		cpi r24,lo8(-1)
 359 012e 01F4      		brne .L7
 126:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error post\r\n"));
 361               	.LM27:
 362 0130 80E0      		ldi r24,lo8(__c.2141)
 363 0132 90E0      		ldi r25,hi8(__c.2141)
 364 0134 0E94 0000 		call nrk_kprintf
 365               	.L7:
 127:main.c        **** 	nrk_kprintf( PSTR("Task2 released semaphore\r\n"));
 367               	.LM28:
 368 0138 80E0      		ldi r24,lo8(__c.2143)
 369 013a 90E0      		ldi r25,hi8(__c.2143)
 370 013c 0E94 0000 		call nrk_kprintf
 128:main.c        **** 	nrk_wait_until_next_period();
 372               	.LM29:
 373 0140 0E94 0000 		call nrk_wait_until_next_period
 129:main.c        **** 	cnt++;
 375               	.LM30:
 376 0144 1F5F      		subi r17,lo8(-(1))
 130:main.c        ****     }
 378               	.LM31:
 379 0146 00C0      		rjmp .L8
 384               	.Lscope2:
 386               		.stabd	78,0,0
 387               		.data
 388               	.LC3:
 389 002d 4D79 206E 		.string	"My node's address is %d\r\n"
 389      6F64 6527 
 389      7320 6164 
 389      6472 6573 
 389      7320 6973 
 390               	.LC4:
 391 0047 5461 736B 		.string	"Task1 PID=%d\r\n"
 391      3120 5049 
 391      443D 2564 
 391      0D0A 00
 392               		.text
 394               	.global	Task1
 396               	Task1:
 397               		.stabd	46,0,0
  84:main.c        **** {
 399               	.LM32:
 400               	.LFBB3:
 401 0148 0F93      		push r16
 402 014a 1F93      		push r17
 403 014c CF93      		push r28
 404 014e DF93      		push r29
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 4 */
 408               	.L__stack_usage = 4
  88:main.c        ****     printf( "My node's address is %d\r\n",NODE_ADDR );
 410               	.LM33:
 411 0150 00D0      		rcall .
 412 0152 00D0      		rcall .
 413 0154 80E0      		ldi r24,lo8(.LC3)
 414 0156 90E0      		ldi r25,hi8(.LC3)
 415 0158 ADB7      		in r26,__SP_L__
 416 015a BEB7      		in r27,__SP_H__
 417 015c 1296      		adiw r26,1+1
 418 015e 9C93      		st X,r25
 419 0160 8E93      		st -X,r24
 420 0162 1197      		sbiw r26,1
 421 0164 1496      		adiw r26,3+1
 422 0166 1C92      		st X,__zero_reg__
 423 0168 1E92      		st -X,__zero_reg__
 424 016a 1397      		sbiw r26,3
 425 016c 0E94 0000 		call printf
  90:main.c        ****     printf( "Task1 PID=%d\r\n",nrk_get_pid());
 427               	.LM34:
 428 0170 0F90      		pop __tmp_reg__
 429 0172 0F90      		pop __tmp_reg__
 430 0174 0F90      		pop __tmp_reg__
 431 0176 0F90      		pop __tmp_reg__
 432 0178 0E94 0000 		call nrk_get_pid
 433 017c 00D0      		rcall .
 434 017e 00D0      		rcall .
 435 0180 EDB7      		in r30,__SP_L__
 436 0182 FEB7      		in r31,__SP_H__
 437 0184 3196      		adiw r30,1
 438 0186 20E0      		ldi r18,lo8(.LC4)
 439 0188 30E0      		ldi r19,hi8(.LC4)
 440 018a ADB7      		in r26,__SP_L__
 441 018c BEB7      		in r27,__SP_H__
 442 018e 1296      		adiw r26,1+1
 443 0190 3C93      		st X,r19
 444 0192 2E93      		st -X,r18
 445 0194 1197      		sbiw r26,1
 446 0196 8283      		std Z+2,r24
 447 0198 1382      		std Z+3,__zero_reg__
 448 019a 0E94 0000 		call printf
 449 019e 0F90      		pop __tmp_reg__
 450 01a0 0F90      		pop __tmp_reg__
 451 01a2 0F90      		pop __tmp_reg__
 452 01a4 0F90      		pop __tmp_reg__
  91:main.c        ****     cnt=0;
 454               	.LM35:
 455 01a6 C0E0      		ldi r28,lo8(0)
 456 01a8 D0E0      		ldi r29,hi8(0)
  94:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 458               	.LM36:
 459 01aa 00E0      		ldi r16,lo8(.LC1)
 460 01ac 10E0      		ldi r17,hi8(.LC1)
 461               	.L12:
  93:main.c        **** 	nrk_led_toggle(ORANGE_LED);
 463               	.LM37:
 464 01ae 80E0      		ldi r24,lo8(0)
 465 01b0 90E0      		ldi r25,hi8(0)
 466 01b2 0E94 0000 		call nrk_led_toggle
  94:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 468               	.LM38:
 469 01b6 00D0      		rcall .
 470 01b8 00D0      		rcall .
 471 01ba EDB7      		in r30,__SP_L__
 472 01bc FEB7      		in r31,__SP_H__
 473 01be 1283      		std Z+2,r17
 474 01c0 0183      		std Z+1,r16
 475 01c2 D483      		std Z+4,r29
 476 01c4 C383      		std Z+3,r28
 477 01c6 0E94 0000 		call printf
  95:main.c        **** 	nrk_kprintf( PSTR("Task1 accessing semaphore\r\n"));
 479               	.LM39:
 480 01ca 0F90      		pop __tmp_reg__
 481 01cc 0F90      		pop __tmp_reg__
 482 01ce 0F90      		pop __tmp_reg__
 483 01d0 0F90      		pop __tmp_reg__
 484 01d2 80E0      		ldi r24,lo8(__c.2120)
 485 01d4 90E0      		ldi r25,hi8(__c.2120)
 486 01d6 0E94 0000 		call nrk_kprintf
  96:main.c        **** 	v = nrk_sem_pend(my_semaphore);
 488               	.LM40:
 489 01da 8091 0000 		lds r24,my_semaphore
 490 01de 9091 0000 		lds r25,my_semaphore+1
 491 01e2 0E94 0000 		call nrk_sem_pend
  97:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error pend\r\n"));
 493               	.LM41:
 494 01e6 8F3F      		cpi r24,lo8(-1)
 495 01e8 01F4      		brne .L10
  97:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error pend\r\n"));
 497               	.LM42:
 498 01ea 80E0      		ldi r24,lo8(__c.2122)
 499 01ec 90E0      		ldi r25,hi8(__c.2122)
 500 01ee 0E94 0000 		call nrk_kprintf
 501               	.L10:
  98:main.c        **** 	nrk_kprintf( PSTR("Task1 holding semaphore\r\n"));
 503               	.LM43:
 504 01f2 80E0      		ldi r24,lo8(__c.2124)
 505 01f4 90E0      		ldi r25,hi8(__c.2124)
 506 01f6 0E94 0000 		call nrk_kprintf
 100:main.c        **** 	nrk_wait_until_next_period();
 508               	.LM44:
 509 01fa 0E94 0000 		call nrk_wait_until_next_period
 101:main.c        **** 	v = nrk_sem_post(my_semaphore);
 511               	.LM45:
 512 01fe 8091 0000 		lds r24,my_semaphore
 513 0202 9091 0000 		lds r25,my_semaphore+1
 514 0206 0E94 0000 		call nrk_sem_post
 102:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error post\r\n"));
 516               	.LM46:
 517 020a 8F3F      		cpi r24,lo8(-1)
 518 020c 01F4      		brne .L11
 102:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error post\r\n"));
 520               	.LM47:
 521 020e 80E0      		ldi r24,lo8(__c.2126)
 522 0210 90E0      		ldi r25,hi8(__c.2126)
 523 0212 0E94 0000 		call nrk_kprintf
 524               	.L11:
 103:main.c        **** 	nrk_kprintf( PSTR("Task1 released semaphore\r\n"));
 526               	.LM48:
 527 0216 80E0      		ldi r24,lo8(__c.2128)
 528 0218 90E0      		ldi r25,hi8(__c.2128)
 529 021a 0E94 0000 		call nrk_kprintf
 104:main.c        **** 	nrk_wait_until_next_period();
 531               	.LM49:
 532 021e 0E94 0000 		call nrk_wait_until_next_period
 105:main.c        **** 	cnt++;
 534               	.LM50:
 535 0222 2196      		adiw r28,1
 106:main.c        ****     }
 537               	.LM51:
 538 0224 00C0      		rjmp .L12
 543               	.Lscope3:
 545               		.stabd	78,0,0
 547               	.global	nrk_create_taskset
 549               	nrk_create_taskset:
 550               		.stabd	46,0,0
 160:main.c        **** 
 161:main.c        **** 
 162:main.c        **** 
 163:main.c        **** }
 164:main.c        **** 
 165:main.c        ****     void
 166:main.c        **** nrk_create_taskset()
 167:main.c        **** {
 552               	.LM52:
 553               	.LFBB4:
 554 0226 0F93      		push r16
 555 0228 1F93      		push r17
 556               	/* prologue: function */
 557               	/* frame size = 0 */
 558               	/* stack size = 2 */
 559               	.L__stack_usage = 2
 168:main.c        ****     TaskOne.task = Task1;
 561               	.LM53:
 562 022a 80E0      		ldi r24,lo8(gs(Task1))
 563 022c 90E0      		ldi r25,hi8(gs(Task1))
 564 022e 9093 0000 		sts TaskOne+5+1,r25
 565 0232 8093 0000 		sts TaskOne+5,r24
 169:main.c        ****     TaskOne.Ptos = (void *) &Stack1[NRK_APP_STACKSIZE];
 567               	.LM54:
 568 0236 80E0      		ldi r24,lo8(Stack1+128)
 569 0238 90E0      		ldi r25,hi8(Stack1+128)
 570 023a 9093 0000 		sts TaskOne+1+1,r25
 571 023e 8093 0000 		sts TaskOne+1,r24
 170:main.c        ****     TaskOne.Pbos = (void *) &Stack1[0];
 573               	.LM55:
 574 0242 80E0      		ldi r24,lo8(Stack1)
 575 0244 90E0      		ldi r25,hi8(Stack1)
 576 0246 9093 0000 		sts TaskOne+3+1,r25
 577 024a 8093 0000 		sts TaskOne+3,r24
 171:main.c        ****     TaskOne.prio = 1;
 579               	.LM56:
 580 024e 11E0      		ldi r17,lo8(1)
 581 0250 1093 0000 		sts TaskOne+8,r17
 172:main.c        ****     TaskOne.FirstActivation = TRUE;
 583               	.LM57:
 584 0254 1093 0000 		sts TaskOne+7,r17
 173:main.c        ****     TaskOne.Type = BASIC_TASK;
 586               	.LM58:
 587 0258 1093 0000 		sts TaskOne+9,r17
 174:main.c        ****     TaskOne.SchType = PREEMPTIVE;
 589               	.LM59:
 590 025c 1093 0000 		sts TaskOne+10,r17
 175:main.c        ****     TaskOne.period.secs = 0;
 592               	.LM60:
 593 0260 1092 0000 		sts TaskOne+11,__zero_reg__
 594 0264 1092 0000 		sts TaskOne+11+1,__zero_reg__
 595 0268 1092 0000 		sts TaskOne+11+2,__zero_reg__
 596 026c 1092 0000 		sts TaskOne+11+3,__zero_reg__
 176:main.c        ****     TaskOne.period.nano_secs = 350*NANOS_PER_MS;
 598               	.LM61:
 599 0270 80E8      		ldi r24,lo8(350000000)
 600 0272 93E9      		ldi r25,hi8(350000000)
 601 0274 ACED      		ldi r26,hlo8(350000000)
 602 0276 B4E1      		ldi r27,hhi8(350000000)
 603 0278 8093 0000 		sts TaskOne+15,r24
 604 027c 9093 0000 		sts TaskOne+15+1,r25
 605 0280 A093 0000 		sts TaskOne+15+2,r26
 606 0284 B093 0000 		sts TaskOne+15+3,r27
 177:main.c        ****     TaskOne.cpu_reserve.secs = 0;
 608               	.LM62:
 609 0288 1092 0000 		sts TaskOne+19,__zero_reg__
 610 028c 1092 0000 		sts TaskOne+19+1,__zero_reg__
 611 0290 1092 0000 		sts TaskOne+19+2,__zero_reg__
 612 0294 1092 0000 		sts TaskOne+19+3,__zero_reg__
 178:main.c        ****     TaskOne.cpu_reserve.nano_secs =  50*NANOS_PER_MS;
 614               	.LM63:
 615 0298 80E8      		ldi r24,lo8(50000000)
 616 029a 90EF      		ldi r25,hi8(50000000)
 617 029c AAEF      		ldi r26,hlo8(50000000)
 618 029e B2E0      		ldi r27,hhi8(50000000)
 619 02a0 8093 0000 		sts TaskOne+23,r24
 620 02a4 9093 0000 		sts TaskOne+23+1,r25
 621 02a8 A093 0000 		sts TaskOne+23+2,r26
 622 02ac B093 0000 		sts TaskOne+23+3,r27
 179:main.c        ****     TaskOne.offset.secs = 0;
 624               	.LM64:
 625 02b0 1092 0000 		sts TaskOne+27,__zero_reg__
 626 02b4 1092 0000 		sts TaskOne+27+1,__zero_reg__
 627 02b8 1092 0000 		sts TaskOne+27+2,__zero_reg__
 628 02bc 1092 0000 		sts TaskOne+27+3,__zero_reg__
 180:main.c        ****     TaskOne.offset.nano_secs= 0;
 630               	.LM65:
 631 02c0 1092 0000 		sts TaskOne+31,__zero_reg__
 632 02c4 1092 0000 		sts TaskOne+31+1,__zero_reg__
 633 02c8 1092 0000 		sts TaskOne+31+2,__zero_reg__
 634 02cc 1092 0000 		sts TaskOne+31+3,__zero_reg__
 181:main.c        ****     nrk_activate_task (&TaskOne);
 636               	.LM66:
 637 02d0 80E0      		ldi r24,lo8(TaskOne)
 638 02d2 90E0      		ldi r25,hi8(TaskOne)
 639 02d4 0E94 0000 		call nrk_activate_task
 182:main.c        **** 
 183:main.c        ****     TaskTwo.task = Task2;
 641               	.LM67:
 642 02d8 80E0      		ldi r24,lo8(gs(Task2))
 643 02da 90E0      		ldi r25,hi8(gs(Task2))
 644 02dc 9093 0000 		sts TaskTwo+5+1,r25
 645 02e0 8093 0000 		sts TaskTwo+5,r24
 184:main.c        ****     TaskTwo.Ptos = (void *) &Stack2[NRK_APP_STACKSIZE];
 647               	.LM68:
 648 02e4 80E0      		ldi r24,lo8(Stack2+128)
 649 02e6 90E0      		ldi r25,hi8(Stack2+128)
 650 02e8 9093 0000 		sts TaskTwo+1+1,r25
 651 02ec 8093 0000 		sts TaskTwo+1,r24
 185:main.c        ****     TaskTwo.Pbos = (void *) &Stack2[0];
 653               	.LM69:
 654 02f0 80E0      		ldi r24,lo8(Stack2)
 655 02f2 90E0      		ldi r25,hi8(Stack2)
 656 02f4 9093 0000 		sts TaskTwo+3+1,r25
 657 02f8 8093 0000 		sts TaskTwo+3,r24
 186:main.c        ****     TaskTwo.prio = 2;
 659               	.LM70:
 660 02fc 02E0      		ldi r16,lo8(2)
 661 02fe 0093 0000 		sts TaskTwo+8,r16
 187:main.c        ****     TaskTwo.FirstActivation = TRUE;
 663               	.LM71:
 664 0302 1093 0000 		sts TaskTwo+7,r17
 188:main.c        ****     TaskTwo.Type = BASIC_TASK;
 666               	.LM72:
 667 0306 1093 0000 		sts TaskTwo+9,r17
 189:main.c        ****     TaskTwo.SchType = PREEMPTIVE;
 669               	.LM73:
 670 030a 1093 0000 		sts TaskTwo+10,r17
 190:main.c        ****     TaskTwo.period.secs = 3;
 672               	.LM74:
 673 030e 83E0      		ldi r24,lo8(3)
 674 0310 90E0      		ldi r25,hi8(3)
 675 0312 A0E0      		ldi r26,hlo8(3)
 676 0314 B0E0      		ldi r27,hhi8(3)
 677 0316 8093 0000 		sts TaskTwo+11,r24
 678 031a 9093 0000 		sts TaskTwo+11+1,r25
 679 031e A093 0000 		sts TaskTwo+11+2,r26
 680 0322 B093 0000 		sts TaskTwo+11+3,r27
 191:main.c        ****     TaskTwo.period.nano_secs = 0;
 682               	.LM75:
 683 0326 1092 0000 		sts TaskTwo+15,__zero_reg__
 684 032a 1092 0000 		sts TaskTwo+15+1,__zero_reg__
 685 032e 1092 0000 		sts TaskTwo+15+2,__zero_reg__
 686 0332 1092 0000 		sts TaskTwo+15+3,__zero_reg__
 192:main.c        ****     TaskTwo.cpu_reserve.secs = 0;
 688               	.LM76:
 689 0336 1092 0000 		sts TaskTwo+19,__zero_reg__
 690 033a 1092 0000 		sts TaskTwo+19+1,__zero_reg__
 691 033e 1092 0000 		sts TaskTwo+19+2,__zero_reg__
 692 0342 1092 0000 		sts TaskTwo+19+3,__zero_reg__
 193:main.c        ****     TaskTwo.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 694               	.LM77:
 695 0346 80E0      		ldi r24,lo8(100000000)
 696 0348 91EE      		ldi r25,hi8(100000000)
 697 034a A5EF      		ldi r26,hlo8(100000000)
 698 034c B5E0      		ldi r27,hhi8(100000000)
 699 034e 8093 0000 		sts TaskTwo+23,r24
 700 0352 9093 0000 		sts TaskTwo+23+1,r25
 701 0356 A093 0000 		sts TaskTwo+23+2,r26
 702 035a B093 0000 		sts TaskTwo+23+3,r27
 194:main.c        ****     TaskTwo.offset.secs = 0;
 704               	.LM78:
 705 035e 1092 0000 		sts TaskTwo+27,__zero_reg__
 706 0362 1092 0000 		sts TaskTwo+27+1,__zero_reg__
 707 0366 1092 0000 		sts TaskTwo+27+2,__zero_reg__
 708 036a 1092 0000 		sts TaskTwo+27+3,__zero_reg__
 195:main.c        ****     TaskTwo.offset.nano_secs= 0;
 710               	.LM79:
 711 036e 1092 0000 		sts TaskTwo+31,__zero_reg__
 712 0372 1092 0000 		sts TaskTwo+31+1,__zero_reg__
 713 0376 1092 0000 		sts TaskTwo+31+2,__zero_reg__
 714 037a 1092 0000 		sts TaskTwo+31+3,__zero_reg__
 196:main.c        ****     nrk_activate_task (&TaskTwo);
 716               	.LM80:
 717 037e 80E0      		ldi r24,lo8(TaskTwo)
 718 0380 90E0      		ldi r25,hi8(TaskTwo)
 719 0382 0E94 0000 		call nrk_activate_task
 197:main.c        **** 
 198:main.c        ****     TaskThree.task = Task3;
 721               	.LM81:
 722 0386 80E0      		ldi r24,lo8(gs(Task3))
 723 0388 90E0      		ldi r25,hi8(gs(Task3))
 724 038a 9093 0000 		sts TaskThree+5+1,r25
 725 038e 8093 0000 		sts TaskThree+5,r24
 199:main.c        ****     TaskThree.Ptos = (void *) &Stack3[NRK_APP_STACKSIZE];
 727               	.LM82:
 728 0392 80E0      		ldi r24,lo8(Stack3+128)
 729 0394 90E0      		ldi r25,hi8(Stack3+128)
 730 0396 9093 0000 		sts TaskThree+1+1,r25
 731 039a 8093 0000 		sts TaskThree+1,r24
 200:main.c        ****     TaskThree.Pbos = (void *) &Stack3[0];
 733               	.LM83:
 734 039e 80E0      		ldi r24,lo8(Stack3)
 735 03a0 90E0      		ldi r25,hi8(Stack3)
 736 03a2 9093 0000 		sts TaskThree+3+1,r25
 737 03a6 8093 0000 		sts TaskThree+3,r24
 201:main.c        ****     TaskThree.prio = 2;
 739               	.LM84:
 740 03aa 0093 0000 		sts TaskThree+8,r16
 202:main.c        ****     TaskThree.FirstActivation = TRUE;
 742               	.LM85:
 743 03ae 1093 0000 		sts TaskThree+7,r17
 203:main.c        ****     TaskThree.Type = BASIC_TASK;
 745               	.LM86:
 746 03b2 1093 0000 		sts TaskThree+9,r17
 204:main.c        ****     TaskThree.SchType = PREEMPTIVE;
 748               	.LM87:
 749 03b6 1093 0000 		sts TaskThree+10,r17
 205:main.c        ****     TaskThree.period.secs = 0;
 751               	.LM88:
 752 03ba 1092 0000 		sts TaskThree+11,__zero_reg__
 753 03be 1092 0000 		sts TaskThree+11+1,__zero_reg__
 754 03c2 1092 0000 		sts TaskThree+11+2,__zero_reg__
 755 03c6 1092 0000 		sts TaskThree+11+3,__zero_reg__
 206:main.c        ****     TaskThree.period.nano_secs = 200*NANOS_PER_MS;
 757               	.LM89:
 758 03ca 80E0      		ldi r24,lo8(200000000)
 759 03cc 92EC      		ldi r25,hi8(200000000)
 760 03ce ABEE      		ldi r26,hlo8(200000000)
 761 03d0 BBE0      		ldi r27,hhi8(200000000)
 762 03d2 8093 0000 		sts TaskThree+15,r24
 763 03d6 9093 0000 		sts TaskThree+15+1,r25
 764 03da A093 0000 		sts TaskThree+15+2,r26
 765 03de B093 0000 		sts TaskThree+15+3,r27
 207:main.c        ****     TaskThree.cpu_reserve.secs = 0;
 767               	.LM90:
 768 03e2 1092 0000 		sts TaskThree+19,__zero_reg__
 769 03e6 1092 0000 		sts TaskThree+19+1,__zero_reg__
 770 03ea 1092 0000 		sts TaskThree+19+2,__zero_reg__
 771 03ee 1092 0000 		sts TaskThree+19+3,__zero_reg__
 208:main.c        ****     TaskThree.cpu_reserve.nano_secs = 10*NANOS_PER_MS;
 773               	.LM91:
 774 03f2 80E8      		ldi r24,lo8(10000000)
 775 03f4 96E9      		ldi r25,hi8(10000000)
 776 03f6 A8E9      		ldi r26,hlo8(10000000)
 777 03f8 B0E0      		ldi r27,hhi8(10000000)
 778 03fa 8093 0000 		sts TaskThree+23,r24
 779 03fe 9093 0000 		sts TaskThree+23+1,r25
 780 0402 A093 0000 		sts TaskThree+23+2,r26
 781 0406 B093 0000 		sts TaskThree+23+3,r27
 209:main.c        ****     TaskThree.offset.secs = 0;
 783               	.LM92:
 784 040a 1092 0000 		sts TaskThree+27,__zero_reg__
 785 040e 1092 0000 		sts TaskThree+27+1,__zero_reg__
 786 0412 1092 0000 		sts TaskThree+27+2,__zero_reg__
 787 0416 1092 0000 		sts TaskThree+27+3,__zero_reg__
 210:main.c        ****     TaskThree.offset.nano_secs= 0;
 789               	.LM93:
 790 041a 1092 0000 		sts TaskThree+31,__zero_reg__
 791 041e 1092 0000 		sts TaskThree+31+1,__zero_reg__
 792 0422 1092 0000 		sts TaskThree+31+2,__zero_reg__
 793 0426 1092 0000 		sts TaskThree+31+3,__zero_reg__
 211:main.c        ****     nrk_activate_task (&TaskThree);
 795               	.LM94:
 796 042a 80E0      		ldi r24,lo8(TaskThree)
 797 042c 90E0      		ldi r25,hi8(TaskThree)
 798 042e 0E94 0000 		call nrk_activate_task
 799               	/* epilogue start */
 212:main.c        **** 
 213:main.c        **** 
 214:main.c        **** }
 801               	.LM95:
 802 0432 1F91      		pop r17
 803 0434 0F91      		pop r16
 804 0436 0895      		ret
 806               	.Lscope4:
 808               		.stabd	78,0,0
 809               		.data
 810               	.LC5:
 811 0056 5374 6172 		.string	"Starting up...\r"
 811      7469 6E67 
 811      2075 702E 
 811      2E2E 0D00 
 812               		.text
 814               	.global	main
 816               	main:
 817               		.stabd	46,0,0
  56:main.c        **** {
 819               	.LM96:
 820               	.LFBB5:
 821               	/* prologue: function */
 822               	/* frame size = 0 */
 823               	/* stack size = 0 */
 824               	.L__stack_usage = 0
  58:main.c        ****     nrk_setup_ports();
 826               	.LM97:
 827 0438 0E94 0000 		call nrk_setup_ports
  59:main.c        ****     nrk_setup_uart(UART_BAUDRATE_115K2);
 829               	.LM98:
 830 043c 87E0      		ldi r24,lo8(7)
 831 043e 90E0      		ldi r25,hi8(7)
 832 0440 0E94 0000 		call nrk_setup_uart
  61:main.c        ****     printf( "Starting up...\r\n" );
 834               	.LM99:
 835 0444 80E0      		ldi r24,lo8(.LC5)
 836 0446 90E0      		ldi r25,hi8(.LC5)
 837 0448 0E94 0000 		call puts
  63:main.c        ****     nrk_init();
 839               	.LM100:
 840 044c 0E94 0000 		call nrk_init
  65:main.c        ****     nrk_led_clr(ORANGE_LED);
 842               	.LM101:
 843 0450 80E0      		ldi r24,lo8(0)
 844 0452 90E0      		ldi r25,hi8(0)
 845 0454 0E94 0000 		call nrk_led_clr
  66:main.c        ****     nrk_led_clr(BLUE_LED);
 847               	.LM102:
 848 0458 8FEF      		ldi r24,lo8(255)
 849 045a 90E0      		ldi r25,hi8(255)
 850 045c 0E94 0000 		call nrk_led_clr
  67:main.c        ****     nrk_led_set(GREEN_LED);
 852               	.LM103:
 853 0460 81E0      		ldi r24,lo8(1)
 854 0462 90E0      		ldi r25,hi8(1)
 855 0464 0E94 0000 		call nrk_led_set
  68:main.c        ****     nrk_led_clr(RED_LED);
 857               	.LM104:
 858 0468 82E0      		ldi r24,lo8(2)
 859 046a 90E0      		ldi r25,hi8(2)
 860 046c 0E94 0000 		call nrk_led_clr
  70:main.c        ****     nrk_time_set(0,0);
 862               	.LM105:
 863 0470 60E0      		ldi r22,lo8(0)
 864 0472 70E0      		ldi r23,hi8(0)
 865 0474 CB01      		movw r24,r22
 866 0476 20E0      		ldi r18,lo8(0)
 867 0478 30E0      		ldi r19,hi8(0)
 868 047a A901      		movw r20,r18
 869 047c 0E94 0000 		call nrk_time_set
  71:main.c        ****     nrk_create_taskset ();
 871               	.LM106:
 872 0480 0E94 0000 		call nrk_create_taskset
  75:main.c        ****     my_semaphore = nrk_sem_create(1,350*NANOS_PER_MS);
 874               	.LM107:
 875 0484 81E0      		ldi r24,lo8(1)
 876 0486 60E8      		ldi r22,lo8(-128)
 877 0488 0E94 0000 		call nrk_sem_create
 878 048c 9093 0000 		sts my_semaphore+1,r25
 879 0490 8093 0000 		sts my_semaphore,r24
  76:main.c        ****     if(my_semaphore==NULL) nrk_kprintf( PSTR("Error creating sem\r\n" ));
 881               	.LM108:
 882 0494 0097      		sbiw r24,0
 883 0496 01F4      		brne .L15
  76:main.c        ****     if(my_semaphore==NULL) nrk_kprintf( PSTR("Error creating sem\r\n" ));
 885               	.LM109:
 886 0498 80E0      		ldi r24,lo8(__c.2114)
 887 049a 90E0      		ldi r25,hi8(__c.2114)
 888 049c 0E94 0000 		call nrk_kprintf
 889               	.L15:
  77:main.c        ****     nrk_start();
 891               	.LM110:
 892 04a0 0E94 0000 		call nrk_start
  80:main.c        **** }
 894               	.LM111:
 895 04a4 80E0      		ldi r24,lo8(0)
 896 04a6 90E0      		ldi r25,hi8(0)
 897               	/* epilogue start */
 898 04a8 0895      		ret
 900               	.Lscope5:
 902               		.stabd	78,0,0
 903               		.comm _nrk_signal_list,4,1
 904               		.comm nrk_idle_task_stk,128,1
 905               		.comm nrk_kernel_stk_ptr,2,1
 906               		.comm error_task,1,1
 907               		.comm error_num,1,1
 908               		.comm _nrk_prev_timer_val,1,1
 909               		.comm _nrk_time_trigger,1,1
 910               		.comm app_timer0_callback,2,1
 911               		.comm app_timer0_prescale,1,1
 912               		.comm Stack1,128,1
 913               		.comm TaskOne,35,1
 914               		.comm Stack2,128,1
 915               		.comm TaskTwo,35,1
 916               		.comm Stack3,128,1
 917               		.comm TaskThree,35,1
 918               		.comm my_semaphore,2,1
 919               		.section	.progmem.data,"a",@progbits
 922               	__c.2158:
 923 0000 5461 736B 		.string	"Task3 FINISHED\r\n"
 923      3320 4649 
 923      4E49 5348 
 923      4544 0D0A 
 923      00
 926               	__c.2156:
 927 0011 5432 2065 		.string	"T2 error post\r\n"
 927      7272 6F72 
 927      2070 6F73 
 927      740D 0A00 
 930               	__c.2154:
 931 0021 5461 736B 		.string	"Task3 is running...\r\n"
 931      3320 6973 
 931      2072 756E 
 931      6E69 6E67 
 931      2E2E 2E0D 
 934               	__c.2152:
 935 0037 5432 2065 		.string	"T2 error pend\r\n"
 935      7272 6F72 
 935      2070 656E 
 935      640D 0A00 
 938               	__c.2150:
 939 0047 5461 736B 		.string	"Task3 STARTED\r\n"
 939      3320 5354 
 939      4152 5445 
 939      440D 0A00 
 942               	__c.2143:
 943 0057 5461 736B 		.string	"Task2 released semaphore\r\n"
 943      3220 7265 
 943      6C65 6173 
 943      6564 2073 
 943      656D 6170 
 946               	__c.2141:
 947 0072 5432 2065 		.string	"T2 error post\r\n"
 947      7272 6F72 
 947      2070 6F73 
 947      740D 0A00 
 950               	__c.2139:
 951 0082 5461 736B 		.string	"Task2 holding semaphore\r\n"
 951      3220 686F 
 951      6C64 696E 
 951      6720 7365 
 951      6D61 7068 
 954               	__c.2137:
 955 009c 5432 2065 		.string	"T2 error pend\r\n"
 955      7272 6F72 
 955      2070 656E 
 955      640D 0A00 
 958               	__c.2135:
 959 00ac 5461 736B 		.string	"Task2 accessing semaphore\r\n"
 959      3220 6163 
 959      6365 7373 
 959      696E 6720 
 959      7365 6D61 
 962               	__c.2128:
 963 00c8 5461 736B 		.string	"Task1 released semaphore\r\n"
 963      3120 7265 
 963      6C65 6173 
 963      6564 2073 
 963      656D 6170 
 966               	__c.2126:
 967 00e3 5431 2065 		.string	"T1 error post\r\n"
 967      7272 6F72 
 967      2070 6F73 
 967      740D 0A00 
 970               	__c.2124:
 971 00f3 5461 736B 		.string	"Task1 holding semaphore\r\n"
 971      3120 686F 
 971      6C64 696E 
 971      6720 7365 
 971      6D61 7068 
 974               	__c.2122:
 975 010d 5431 2065 		.string	"T1 error pend\r\n"
 975      7272 6F72 
 975      2070 656E 
 975      640D 0A00 
 978               	__c.2120:
 979 011d 5461 736B 		.string	"Task1 accessing semaphore\r\n"
 979      3120 6163 
 979      6365 7373 
 979      696E 6720 
 979      7365 6D61 
 982               	__c.2114:
 983 0139 4572 726F 		.string	"Error creating sem\r\n"
 983      7220 6372 
 983      6561 7469 
 983      6E67 2073 
 983      656D 0D0A 
 1000               		.text
 1002               	.Letext0:
 1003               	.global __do_copy_data
 1004               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccaP6vg1.s:2      *ABS*:0000003f __SREG__
     /tmp/ccaP6vg1.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccaP6vg1.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccaP6vg1.s:5      *ABS*:00000034 __CCP__
     /tmp/ccaP6vg1.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccaP6vg1.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccaP6vg1.s:146    .text:00000000 Task3
     /tmp/ccaP6vg1.s:938    .progmem.data:00000047 __c.2150
     /tmp/ccaP6vg1.s:930    .progmem.data:00000021 __c.2154
     /tmp/ccaP6vg1.s:922    .progmem.data:00000000 __c.2158
     /tmp/ccaP6vg1.s:255    .text:0000008c Task2
     /tmp/ccaP6vg1.s:958    .progmem.data:000000ac __c.2135
                            *COM*:00000002 my_semaphore
     /tmp/ccaP6vg1.s:954    .progmem.data:0000009c __c.2137
     /tmp/ccaP6vg1.s:950    .progmem.data:00000082 __c.2139
     /tmp/ccaP6vg1.s:946    .progmem.data:00000072 __c.2141
     /tmp/ccaP6vg1.s:942    .progmem.data:00000057 __c.2143
     /tmp/ccaP6vg1.s:396    .text:00000148 Task1
     /tmp/ccaP6vg1.s:978    .progmem.data:0000011d __c.2120
     /tmp/ccaP6vg1.s:974    .progmem.data:0000010d __c.2122
     /tmp/ccaP6vg1.s:970    .progmem.data:000000f3 __c.2124
     /tmp/ccaP6vg1.s:966    .progmem.data:000000e3 __c.2126
     /tmp/ccaP6vg1.s:962    .progmem.data:000000c8 __c.2128
     /tmp/ccaP6vg1.s:549    .text:00000226 nrk_create_taskset
                            *COM*:00000023 TaskOne
                            *COM*:00000080 Stack1
                            *COM*:00000023 TaskTwo
                            *COM*:00000080 Stack2
                            *COM*:00000023 TaskThree
                            *COM*:00000080 Stack3
     /tmp/ccaP6vg1.s:816    .text:00000438 main
     /tmp/ccaP6vg1.s:982    .progmem.data:00000139 __c.2114
                            *COM*:00000004 _nrk_signal_list
                            *COM*:00000080 nrk_idle_task_stk
                            *COM*:00000002 nrk_kernel_stk_ptr
                            *COM*:00000001 error_task
                            *COM*:00000001 error_num
                            *COM*:00000001 _nrk_prev_timer_val
                            *COM*:00000001 _nrk_time_trigger
                            *COM*:00000002 app_timer0_callback
                            *COM*:00000001 app_timer0_prescale
     /tmp/ccaP6vg1.s:926    .progmem.data:00000011 __c.2156
     /tmp/ccaP6vg1.s:934    .progmem.data:00000037 __c.2152

UNDEFINED SYMBOLS
nrk_get_pid
printf
nrk_led_toggle
nrk_kprintf
nrk_wait_until_next_period
nrk_sem_pend
nrk_sem_post
nrk_activate_task
nrk_setup_ports
nrk_setup_uart
puts
nrk_init
nrk_led_clr
nrk_led_set
nrk_time_set
nrk_sem_create
nrk_start
__do_copy_data
__do_clear_bss
