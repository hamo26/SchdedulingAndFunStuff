   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 298               		.data
 299               	.LC0:
 300 0000 4D79 206E 		.string	"My node's address is %d\r\n"
 300      6F64 6527 
 300      7320 6164 
 300      6472 6573 
 300      7320 6973 
 301               	.LC1:
 302 001a 5461 736B 		.string	"Task1 PID=%d\r\n"
 302      3120 5049 
 302      443D 2564 
 302      0D0A 00
 303               	.LC2:
 304 0029 5461 736B 		.string	"Task1 timer=%u\r\n"
 304      3120 7469 
 304      6D65 723D 
 304      2575 0D0A 
 304      00
 305               		.text
 307               	.global	Task1
 309               	Task1:
 310               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *******************************************************************************/
  23:main.c        **** 
  24:main.c        **** 
  25:main.c        **** #include <nrk.h>
  26:main.c        **** #include <include.h>
  27:main.c        **** #include <ulib.h>
  28:main.c        **** #include <stdio.h>
  29:main.c        **** #include <avr/sleep.h>
  30:main.c        **** #include <hal.h>
  31:main.c        **** #include <nrk_error.h>
  32:main.c        **** #include <nrk_timer.h>
  33:main.c        **** #include <nrk_stack_check.h>
  34:main.c        **** 
  35:main.c        **** 
  36:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  37:main.c        **** nrk_task_type TaskOne;
  38:main.c        **** void Task1(void);
  39:main.c        **** 
  40:main.c        **** /*NRK_STK Stack2[NRK_APP_STACKSIZE];
  41:main.c        **** nrk_task_type TaskTwo;
  42:main.c        **** void Task2 (void);
  43:main.c        **** 
  44:main.c        **** NRK_STK Stack3[NRK_APP_STACKSIZE];
  45:main.c        **** nrk_task_type TaskThree;
  46:main.c        **** void Task3 (void);*/
  47:main.c        **** 
  48:main.c        **** 
  49:main.c        **** void nrk_create_taskset();
  50:main.c        **** 
  51:main.c        **** int
  52:main.c        **** main ()
  53:main.c        **** {
  54:main.c        ****   uint8_t t;
  55:main.c        ****   
  56:main.c        ****   nrk_setup_ports();
  57:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
  58:main.c        ****   
  59:main.c        ****   nrk_kprintf( PSTR("Starting up...\r\n") );
  60:main.c        **** 
  61:main.c        ****   nrk_init();
  62:main.c        **** 
  63:main.c        ****  
  64:main.c        ****   nrk_time_set(0,0);
  65:main.c        ****   nrk_create_taskset ();
  66:main.c        ****   nrk_start();
  67:main.c        ****   return 0;
  68:main.c        **** }
  69:main.c        **** 
  70:main.c        **** void my_timer_callback()
  71:main.c        **** {
  72:main.c        **** 	nrk_led_toggle(ORANGE_LED);
  73:main.c        **** 	//nrk_gpio_toggle(NRK_DEBUG_0);
  74:main.c        **** 	// Normally you should not call long functions like printf
  75:main.c        **** 	// inside a interrupt callback
  76:main.c        **** 	//nrk_kprintf( PSTR("*** Timer interrupt!\r\n"));
  77:main.c        **** }
  78:main.c        **** 
  79:main.c        **** void Task1()
  80:main.c        **** {
 312               	.LM0:
 313               	.LFBB1:
 314 0000 CF93      		push r28
 315 0002 DF93      		push r29
 316               	/* prologue: function */
 317               	/* frame size = 0 */
 318               	/* stack size = 2 */
 319               	.L__stack_usage = 2
  81:main.c        **** uint16_t cnt;
  82:main.c        **** uint8_t val;
  83:main.c        **** 
  84:main.c        **** printf( "My node's address is %d\r\n",NODE_ADDR );
 321               	.LM1:
 322 0004 00D0      		rcall .
 323 0006 00D0      		rcall .
 324 0008 80E0      		ldi r24,lo8(.LC0)
 325 000a 90E0      		ldi r25,hi8(.LC0)
 326 000c ADB7      		in r26,__SP_L__
 327 000e BEB7      		in r27,__SP_H__
 328 0010 1296      		adiw r26,1+1
 329 0012 9C93      		st X,r25
 330 0014 8E93      		st -X,r24
 331 0016 1197      		sbiw r26,1
 332 0018 1496      		adiw r26,3+1
 333 001a 1C92      		st X,__zero_reg__
 334 001c 1E92      		st -X,__zero_reg__
 335 001e 1397      		sbiw r26,3
 336 0020 0E94 0000 		call printf
  85:main.c        **** 
  86:main.c        ****   printf( "Task1 PID=%d\r\n",nrk_get_pid());
 338               	.LM2:
 339 0024 0F90      		pop __tmp_reg__
 340 0026 0F90      		pop __tmp_reg__
 341 0028 0F90      		pop __tmp_reg__
 342 002a 0F90      		pop __tmp_reg__
 343 002c 0E94 0000 		call nrk_get_pid
 344 0030 00D0      		rcall .
 345 0032 00D0      		rcall .
 346 0034 EDB7      		in r30,__SP_L__
 347 0036 FEB7      		in r31,__SP_H__
 348 0038 3196      		adiw r30,1
 349 003a 20E0      		ldi r18,lo8(.LC1)
 350 003c 30E0      		ldi r19,hi8(.LC1)
 351 003e ADB7      		in r26,__SP_L__
 352 0040 BEB7      		in r27,__SP_H__
 353 0042 1296      		adiw r26,1+1
 354 0044 3C93      		st X,r19
 355 0046 2E93      		st -X,r18
 356 0048 1197      		sbiw r26,1
 357 004a 8283      		std Z+2,r24
 358 004c 1382      		std Z+3,__zero_reg__
 359 004e 0E94 0000 		call printf
  87:main.c        ****   cnt=0;
  88:main.c        **** 
  89:main.c        ****   // Setup application timer with:
  90:main.c        ****   //       Prescaler = 5 
  91:main.c        ****   //       Compare Match = 25000
  92:main.c        ****   //       Sys Clock = 16 MHz
  93:main.c        ****   // Prescaler 5 means divide sys clock by 1024
  94:main.c        ****   // 16000000 / 1024 = 15625 Hz clock
  95:main.c        ****   // 1 / 15625 = 0.064 ms per tick
  96:main.c        ****   // 0.064 ms * 15625 = ~1000 ms / per interrupt callback
  97:main.c        **** 
  98:main.c        ****   val=nrk_timer_int_configure(NRK_APP_TIMER_0, 1, 40000, &my_timer_callback );// this will give a 4
 361               	.LM3:
 362 0052 0F90      		pop __tmp_reg__
 363 0054 0F90      		pop __tmp_reg__
 364 0056 0F90      		pop __tmp_reg__
 365 0058 0F90      		pop __tmp_reg__
 366 005a 80E0      		ldi r24,lo8(0)
 367 005c 61E0      		ldi r22,lo8(1)
 368 005e 70E0      		ldi r23,hi8(1)
 369 0060 40E4      		ldi r20,lo8(-25536)
 370 0062 5CE9      		ldi r21,hi8(-25536)
 371 0064 20E0      		ldi r18,lo8(gs(my_timer_callback))
 372 0066 30E0      		ldi r19,hi8(gs(my_timer_callback))
 373 0068 0E94 0000 		call nrk_timer_int_configure
  99:main.c        ****   if(val==NRK_OK) nrk_kprintf( PSTR("Callback timer setup\r\n"));
 375               	.LM4:
 376 006c 8130      		cpi r24,lo8(1)
 377 006e 01F4      		brne .L2
 379               	.LM5:
 380 0070 80E0      		ldi r24,lo8(__c.2765)
 381 0072 90E0      		ldi r25,hi8(__c.2765)
 382 0074 00C0      		rjmp .L5
 383               	.L2:
 100:main.c        ****   else nrk_kprintf( PSTR("Error setting up timer callback\r\n"));
 385               	.LM6:
 386 0076 80E0      		ldi r24,lo8(__c.2767)
 387 0078 90E0      		ldi r25,hi8(__c.2767)
 388               	.L5:
 389 007a 0E94 0000 		call nrk_kprintf
 101:main.c        **** 
 102:main.c        ****   // Zero the timer...
 103:main.c        ****   nrk_timer_int_reset(NRK_APP_TIMER_0);
 391               	.LM7:
 392 007e 80E0      		ldi r24,lo8(0)
 393 0080 0E94 0000 		call nrk_timer_int_reset
 104:main.c        ****   // Start the timer...
 105:main.c        ****   nrk_timer_int_start(NRK_APP_TIMER_0);
 395               	.LM8:
 396 0084 80E0      		ldi r24,lo8(0)
 397 0086 0E94 0000 		call nrk_timer_int_start
 106:main.c        **** 
 107:main.c        ****   while(1) {
 108:main.c        **** 	cnt=nrk_timer_int_read(NRK_APP_TIMER_0);
 109:main.c        **** 	printf( "Task1 timer=%u\r\n",cnt );
 399               	.LM9:
 400 008a C0E0      		ldi r28,lo8(.LC2)
 401 008c D0E0      		ldi r29,hi8(.LC2)
 402               	.L4:
 108:main.c        **** 	cnt=nrk_timer_int_read(NRK_APP_TIMER_0);
 404               	.LM10:
 405 008e 80E0      		ldi r24,lo8(0)
 406 0090 0E94 0000 		call nrk_timer_int_read
 408               	.LM11:
 409 0094 00D0      		rcall .
 410 0096 00D0      		rcall .
 411 0098 EDB7      		in r30,__SP_L__
 412 009a FEB7      		in r31,__SP_H__
 413 009c D283      		std Z+2,r29
 414 009e C183      		std Z+1,r28
 415 00a0 9483      		std Z+4,r25
 416 00a2 8383      		std Z+3,r24
 417 00a4 0E94 0000 		call printf
 110:main.c        **** 	nrk_wait_until_next_period();
 419               	.LM12:
 420 00a8 0F90      		pop __tmp_reg__
 421 00aa 0F90      		pop __tmp_reg__
 422 00ac 0F90      		pop __tmp_reg__
 423 00ae 0F90      		pop __tmp_reg__
 424 00b0 0E94 0000 		call nrk_wait_until_next_period
 425 00b4 00C0      		rjmp .L4
 427               	.Lscope1:
 429               		.stabd	78,0,0
 431               	.global	my_timer_callback
 433               	my_timer_callback:
 434               		.stabd	46,0,0
  71:main.c        **** {
 436               	.LM13:
 437               	.LFBB2:
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440               	/* stack size = 0 */
 441               	.L__stack_usage = 0
  72:main.c        **** 	nrk_led_toggle(ORANGE_LED);
 443               	.LM14:
 444 00b6 82E0      		ldi r24,lo8(2)
 445 00b8 90E0      		ldi r25,hi8(2)
 446 00ba 0E94 0000 		call nrk_led_toggle
 447               	/* epilogue start */
  77:main.c        **** }
 449               	.LM15:
 450 00be 0895      		ret
 452               	.Lscope2:
 454               		.stabd	78,0,0
 456               	.global	nrk_create_taskset
 458               	nrk_create_taskset:
 459               		.stabd	46,0,0
 111:main.c        **** 	}
 112:main.c        **** }
 113:main.c        **** 
 114:main.c        **** /*void Task2()
 115:main.c        **** {
 116:main.c        ****   uint8_t cnt;
 117:main.c        ****   printf( "Task2 PID=%d\r\n",nrk_get_pid());
 118:main.c        ****   cnt=0;
 119:main.c        ****   while(1) {
 120:main.c        **** 	nrk_led_toggle(GREEN_LED);
 121:main.c        **** 	printf( "Task2 cnt=%d\r\n",cnt );
 122:main.c        **** 	nrk_wait_until_next_period();
 123:main.c        **** 	cnt++;
 124:main.c        ****   	if(cnt==25) 
 125:main.c        **** 		{
 126:main.c        **** 		nrk_led_clr(ORANGE_LED);
 127:main.c        **** 		nrk_kprintf( PSTR("*** Timer stopped by Task2!\r\n" ));
 128:main.c        **** 		nrk_timer_int_stop(NRK_APP_TIMER_0);
 129:main.c        **** 		}
 130:main.c        **** 	}
 131:main.c        **** }
 132:main.c        **** 
 133:main.c        **** void Task3()
 134:main.c        **** {
 135:main.c        **** uint16_t cnt;
 136:main.c        **** uint16_t i;
 137:main.c        ****   printf( "Task3 PID=%d\r\n",nrk_get_pid());
 138:main.c        ****   cnt=0;
 139:main.c        ****   while(1) {
 140:main.c        **** 	printf( "Task3 cnt=%d\r\n",cnt );
 141:main.c        **** 	nrk_wait_until_next_period();
 142:main.c        **** 	cnt++;
 143:main.c        **** 	}
 144:main.c        **** }*/
 145:main.c        **** 
 146:main.c        **** 
 147:main.c        **** 
 148:main.c        **** void
 149:main.c        **** nrk_create_taskset()
 150:main.c        **** {
 461               	.LM16:
 462               	.LFBB3:
 463               	/* prologue: function */
 464               	/* frame size = 0 */
 465               	/* stack size = 0 */
 466               	.L__stack_usage = 0
 151:main.c        ****   TaskOne.task = Task1;
 468               	.LM17:
 469 00c0 80E0      		ldi r24,lo8(gs(Task1))
 470 00c2 90E0      		ldi r25,hi8(gs(Task1))
 471 00c4 9093 0000 		sts TaskOne+5+1,r25
 472 00c8 8093 0000 		sts TaskOne+5,r24
 152:main.c        ****   TaskOne.Ptos = (void *) &Stack1[NRK_APP_STACKSIZE];
 474               	.LM18:
 475 00cc 80E0      		ldi r24,lo8(Stack1+128)
 476 00ce 90E0      		ldi r25,hi8(Stack1+128)
 477 00d0 9093 0000 		sts TaskOne+1+1,r25
 478 00d4 8093 0000 		sts TaskOne+1,r24
 153:main.c        ****   TaskOne.Pbos = (void *) &Stack1[0];
 480               	.LM19:
 481 00d8 80E0      		ldi r24,lo8(Stack1)
 482 00da 90E0      		ldi r25,hi8(Stack1)
 483 00dc 9093 0000 		sts TaskOne+3+1,r25
 484 00e0 8093 0000 		sts TaskOne+3,r24
 154:main.c        ****   TaskOne.prio = 1;
 486               	.LM20:
 487 00e4 81E0      		ldi r24,lo8(1)
 488 00e6 8093 0000 		sts TaskOne+8,r24
 155:main.c        ****   TaskOne.FirstActivation = TRUE;
 490               	.LM21:
 491 00ea 8093 0000 		sts TaskOne+7,r24
 156:main.c        ****   TaskOne.Type = BASIC_TASK;
 493               	.LM22:
 494 00ee 8093 0000 		sts TaskOne+9,r24
 157:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 496               	.LM23:
 497 00f2 8093 0000 		sts TaskOne+10,r24
 158:main.c        ****   TaskOne.period.secs = 0;
 499               	.LM24:
 500 00f6 1092 0000 		sts TaskOne+11,__zero_reg__
 501 00fa 1092 0000 		sts TaskOne+11+1,__zero_reg__
 502 00fe 1092 0000 		sts TaskOne+11+2,__zero_reg__
 503 0102 1092 0000 		sts TaskOne+11+3,__zero_reg__
 159:main.c        ****   TaskOne.period.nano_secs = 250*NANOS_PER_MS;
 505               	.LM25:
 506 0106 80E8      		ldi r24,lo8(250000000)
 507 0108 92EB      		ldi r25,hi8(250000000)
 508 010a A6EE      		ldi r26,hlo8(250000000)
 509 010c BEE0      		ldi r27,hhi8(250000000)
 510 010e 8093 0000 		sts TaskOne+15,r24
 511 0112 9093 0000 		sts TaskOne+15+1,r25
 512 0116 A093 0000 		sts TaskOne+15+2,r26
 513 011a B093 0000 		sts TaskOne+15+3,r27
 160:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 515               	.LM26:
 516 011e 1092 0000 		sts TaskOne+19,__zero_reg__
 517 0122 1092 0000 		sts TaskOne+19+1,__zero_reg__
 518 0126 1092 0000 		sts TaskOne+19+2,__zero_reg__
 519 012a 1092 0000 		sts TaskOne+19+3,__zero_reg__
 161:main.c        ****   TaskOne.cpu_reserve.nano_secs =  50*NANOS_PER_MS;
 521               	.LM27:
 522 012e 80E8      		ldi r24,lo8(50000000)
 523 0130 90EF      		ldi r25,hi8(50000000)
 524 0132 AAEF      		ldi r26,hlo8(50000000)
 525 0134 B2E0      		ldi r27,hhi8(50000000)
 526 0136 8093 0000 		sts TaskOne+23,r24
 527 013a 9093 0000 		sts TaskOne+23+1,r25
 528 013e A093 0000 		sts TaskOne+23+2,r26
 529 0142 B093 0000 		sts TaskOne+23+3,r27
 162:main.c        ****   TaskOne.offset.secs = 0;
 531               	.LM28:
 532 0146 1092 0000 		sts TaskOne+27,__zero_reg__
 533 014a 1092 0000 		sts TaskOne+27+1,__zero_reg__
 534 014e 1092 0000 		sts TaskOne+27+2,__zero_reg__
 535 0152 1092 0000 		sts TaskOne+27+3,__zero_reg__
 163:main.c        ****   TaskOne.offset.nano_secs= 0;
 537               	.LM29:
 538 0156 1092 0000 		sts TaskOne+31,__zero_reg__
 539 015a 1092 0000 		sts TaskOne+31+1,__zero_reg__
 540 015e 1092 0000 		sts TaskOne+31+2,__zero_reg__
 541 0162 1092 0000 		sts TaskOne+31+3,__zero_reg__
 164:main.c        ****   nrk_activate_task (&TaskOne);
 543               	.LM30:
 544 0166 80E0      		ldi r24,lo8(TaskOne)
 545 0168 90E0      		ldi r25,hi8(TaskOne)
 546 016a 0E94 0000 		call nrk_activate_task
 547               	/* epilogue start */
 165:main.c        **** 
 166:main.c        ****   /*TaskTwo.task = Task2;
 167:main.c        ****   TaskTwo.Ptos = (void *) &Stack2[NRK_APP_STACKSIZE];
 168:main.c        ****   TaskTwo.Pbos = (void *) &Stack2[0];
 169:main.c        ****   TaskTwo.prio = 2;
 170:main.c        ****   TaskTwo.FirstActivation = TRUE;
 171:main.c        ****   TaskTwo.Type = BASIC_TASK;
 172:main.c        ****   TaskTwo.SchType = PREEMPTIVE;
 173:main.c        ****   TaskTwo.period.secs = 0;
 174:main.c        ****   TaskTwo.period.nano_secs = 500*NANOS_PER_MS;
 175:main.c        ****   TaskTwo.cpu_reserve.secs = 0;
 176:main.c        ****   TaskTwo.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 177:main.c        ****   TaskTwo.offset.secs = 0;
 178:main.c        ****   TaskTwo.offset.nano_secs= 0;
 179:main.c        ****   nrk_activate_task (&TaskTwo);
 180:main.c        **** 
 181:main.c        **** 
 182:main.c        ****   TaskThree.task = Task3;
 183:main.c        ****   TaskThree.Ptos = (void *) &Stack3[NRK_APP_STACKSIZE];
 184:main.c        ****   TaskThree.Pbos = (void *) &Stack3[0];
 185:main.c        ****   TaskThree.prio = 3;
 186:main.c        ****   TaskThree.FirstActivation = TRUE;
 187:main.c        ****   TaskThree.Type = BASIC_TASK;
 188:main.c        ****   TaskThree.SchType = PREEMPTIVE;
 189:main.c        ****   TaskThree.period.secs = 1;
 190:main.c        ****   TaskThree.period.nano_secs = 0;
 191:main.c        ****   TaskThree.cpu_reserve.secs = 0;
 192:main.c        ****   TaskThree.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 193:main.c        ****   TaskThree.offset.secs = 0;
 194:main.c        ****   TaskThree.offset.nano_secs= 0;
 195:main.c        ****   nrk_activate_task (&TaskThree);*/
 196:main.c        **** 
 197:main.c        **** 
 198:main.c        **** 
 199:main.c        **** 
 200:main.c        **** }
 549               	.LM31:
 550 016e 0895      		ret
 552               	.Lscope3:
 554               		.stabd	78,0,0
 556               	.global	main
 558               	main:
 559               		.stabd	46,0,0
  53:main.c        **** {
 561               	.LM32:
 562               	.LFBB4:
 563               	/* prologue: function */
 564               	/* frame size = 0 */
 565               	/* stack size = 0 */
 566               	.L__stack_usage = 0
  56:main.c        ****   nrk_setup_ports();
 568               	.LM33:
 569 0170 0E94 0000 		call nrk_setup_ports
  57:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 571               	.LM34:
 572 0174 80E1      		ldi r24,lo8(16)
 573 0176 90E0      		ldi r25,hi8(16)
 574 0178 0E94 0000 		call nrk_setup_uart
  59:main.c        ****   nrk_kprintf( PSTR("Starting up...\r\n") );
 576               	.LM35:
 577 017c 80E0      		ldi r24,lo8(__c.2757)
 578 017e 90E0      		ldi r25,hi8(__c.2757)
 579 0180 0E94 0000 		call nrk_kprintf
  61:main.c        ****   nrk_init();
 581               	.LM36:
 582 0184 0E94 0000 		call nrk_init
  64:main.c        ****   nrk_time_set(0,0);
 584               	.LM37:
 585 0188 60E0      		ldi r22,lo8(0)
 586 018a 70E0      		ldi r23,hi8(0)
 587 018c CB01      		movw r24,r22
 588 018e 20E0      		ldi r18,lo8(0)
 589 0190 30E0      		ldi r19,hi8(0)
 590 0192 A901      		movw r20,r18
 591 0194 0E94 0000 		call nrk_time_set
  65:main.c        ****   nrk_create_taskset ();
 593               	.LM38:
 594 0198 0E94 0000 		call nrk_create_taskset
  66:main.c        ****   nrk_start();
 596               	.LM39:
 597 019c 0E94 0000 		call nrk_start
  68:main.c        **** }
 599               	.LM40:
 600 01a0 80E0      		ldi r24,lo8(0)
 601 01a2 90E0      		ldi r25,hi8(0)
 602               	/* epilogue start */
 603 01a4 0895      		ret
 605               	.Lscope4:
 607               		.stabd	78,0,0
 608               		.comm _nrk_signal_list,4,1
 609               		.comm nrk_idle_task_stk,128,1
 610               		.comm nrk_kernel_stk_ptr,2,1
 611               		.comm error_task,1,1
 612               		.comm error_num,1,1
 613               		.comm _nrk_prev_timer_val,1,1
 614               		.comm _nrk_time_trigger,1,1
 615               		.comm app_timer0_callback,2,1
 616               		.comm app_timer0_prescale,1,1
 617               		.comm Stack1,128,1
 618               		.comm TaskOne,35,1
 619               		.section	.progmem.data,"a",@progbits
 622               	__c.2767:
 623 0000 4572 726F 		.string	"Error setting up timer callback\r\n"
 623      7220 7365 
 623      7474 696E 
 623      6720 7570 
 623      2074 696D 
 626               	__c.2765:
 627 0022 4361 6C6C 		.string	"Callback timer setup\r\n"
 627      6261 636B 
 627      2074 696D 
 627      6572 2073 
 627      6574 7570 
 630               	__c.2757:
 631 0039 5374 6172 		.string	"Starting up...\r\n"
 631      7469 6E67 
 631      2075 702E 
 631      2E2E 0D0A 
 631      00
 643               		.text
 645               	.Letext0:
 646               	.global __do_copy_data
 647               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cc0vt6MM.s:2      *ABS*:0000003f __SREG__
     /tmp/cc0vt6MM.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc0vt6MM.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc0vt6MM.s:5      *ABS*:00000034 __CCP__
     /tmp/cc0vt6MM.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc0vt6MM.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc0vt6MM.s:309    .text:00000000 Task1
     /tmp/cc0vt6MM.s:433    .text:000000b6 my_timer_callback
     /tmp/cc0vt6MM.s:626    .progmem.data:00000022 __c.2765
     /tmp/cc0vt6MM.s:622    .progmem.data:00000000 __c.2767
     /tmp/cc0vt6MM.s:458    .text:000000c0 nrk_create_taskset
                            *COM*:00000023 TaskOne
                            *COM*:00000080 Stack1
     /tmp/cc0vt6MM.s:558    .text:00000170 main
     /tmp/cc0vt6MM.s:630    .progmem.data:00000039 __c.2757
                            *COM*:00000004 _nrk_signal_list
                            *COM*:00000080 nrk_idle_task_stk
                            *COM*:00000002 nrk_kernel_stk_ptr
                            *COM*:00000001 error_task
                            *COM*:00000001 error_num
                            *COM*:00000001 _nrk_prev_timer_val
                            *COM*:00000001 _nrk_time_trigger
                            *COM*:00000002 app_timer0_callback
                            *COM*:00000001 app_timer0_prescale

UNDEFINED SYMBOLS
printf
nrk_get_pid
nrk_timer_int_configure
nrk_kprintf
nrk_timer_int_reset
nrk_timer_int_start
nrk_timer_int_read
nrk_wait_until_next_period
nrk_led_toggle
nrk_activate_task
nrk_setup_ports
nrk_setup_uart
nrk_init
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
